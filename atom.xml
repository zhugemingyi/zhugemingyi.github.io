<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>First Try</title>
  
  
  <link href="https://zhugemingyi.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhugemingyi.github.io/"/>
  <updated>2021-07-05T05:34:02.803Z</updated>
  <id>https://zhugemingyi.github.io/</id>
  
  <author>
    <name>zhugemingyi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python排序算法</title>
    <link href="https://zhugemingyi.github.io/2021/07/05/python%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://zhugemingyi.github.io/2021/07/05/python%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-07-05T01:19:10.000Z</published>
    <updated>2021-07-05T05:34:02.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 遍历所有数组元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># Last i elements are already in place</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-i-<span class="number">1</span>):</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] :</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br></pre></td></tr></table></figure><p>快速排序使用分治法策略来把一个序列分为较小和较大的2个子序列，然后递归地排序两个子序列。</p><p>步骤为：</p><ul><li>挑选基准值：从数列中挑出一个元素，称为”基准”;</li><li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成;</li><li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。</li></ul><p>递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。</p><p>选取基准值有数种具体方法，此选取方法对排序的时间性能有决定性影响。</p><p><img src="/.io//quickSort.gif" alt="quickSort"></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 遍历所有数组元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># Last i elements are already in place</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-i-<span class="number">1</span>):</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] :</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br></pre></td></tr></table></figure><p>冒泡排序重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><p><img src="/.io//bubbleSort.gif" alt="bubbleSort"></p><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span>(<span class="params">arr, n, i</span>):</span> </span><br><span class="line">    largest = i  </span><br><span class="line">    l = <span class="number">2</span> * i + <span class="number">1</span>     <span class="comment"># left = 2*i + 1 </span></span><br><span class="line">    r = <span class="number">2</span> * i + <span class="number">2</span>     <span class="comment"># right = 2*i + 2 </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> l &lt; n <span class="keyword">and</span> arr[i] &lt; arr[l]: </span><br><span class="line">        largest = l </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> r &lt; n <span class="keyword">and</span> arr[largest] &lt; arr[r]: </span><br><span class="line">        largest = r </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> largest != i: </span><br><span class="line">        arr[i],arr[largest] = arr[largest],arr[i]  <span class="comment"># 交换</span></span><br><span class="line">  </span><br><span class="line">        heapify(arr, n, largest) </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span>(<span class="params">arr</span>):</span><span class="comment"># main</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># Build a maxheap. </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, -<span class="number">1</span>, -<span class="number">1</span>): </span><br><span class="line">        heapify(arr, n, i) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 一个个交换元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>): </span><br><span class="line">        arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]   <span class="comment"># 交换</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>) </span><br></pre></td></tr></table></figure><p>堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。</p><p><img src="/.io//heapSort.gif" alt="heapSort"></p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">arr, l, m, r</span>):</span> </span><br><span class="line">    n1 = m - l + <span class="number">1</span></span><br><span class="line">    n2 = r- m </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 创建临时数组</span></span><br><span class="line">    L = [<span class="number">0</span>] * (n1)</span><br><span class="line">    R = [<span class="number">0</span>] * (n2)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 拷贝数据到临时数组 arrays L[] 和 R[] </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span> , n1): </span><br><span class="line">        L[i] = arr[l + i] </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span> , n2): </span><br><span class="line">        R[j] = arr[m + <span class="number">1</span> + j] </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 归并临时数组到 arr[l..r] </span></span><br><span class="line">    i = <span class="number">0</span>     <span class="comment"># 初始化第一个子数组的索引</span></span><br><span class="line">    j = <span class="number">0</span>     <span class="comment"># 初始化第二个子数组的索引</span></span><br><span class="line">    k = l     <span class="comment"># 初始归并子数组的索引</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> i &lt; n1 <span class="keyword">and</span> j &lt; n2 : </span><br><span class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]: </span><br><span class="line">            arr[k] = L[i] </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            arr[k] = R[j] </span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 拷贝 L[] 的保留元素</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n1: </span><br><span class="line">        arr[k] = L[i] </span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 拷贝 R[] 的保留元素</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; n2: </span><br><span class="line">        arr[k] = R[j] </span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">arr,l,r</span>):</span><span class="comment"># eg:mergeSort(arr,0,len(arr)-1)</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; r: </span><br><span class="line">  </span><br><span class="line">        m = <span class="built_in">int</span>((l+(r-<span class="number">1</span>))/<span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">        mergeSort(arr, l, m) </span><br><span class="line">        mergeSort(arr, m+<span class="number">1</span>, r) </span><br><span class="line">        merge(arr, l, m, r) </span><br></pre></td></tr></table></figure><p>归并排序是创建在归并操作上的一种有效的排序算法。该算法是采用分治法（的一个非常典型的应用。</p><p>分治法:</p><ul><li>分割：递归地把当前序列平均分割成两半。</li><li>集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。</li></ul><p><img src="/.io//mergeSort.gif" alt="mergeSort"></p><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span>(<span class="params">arr</span>):</span> </span><br><span class="line">  </span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    gap = <span class="built_in">int</span>(n/<span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>: </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap,n): </span><br><span class="line">            temp = arr[i] </span><br><span class="line">            j = i </span><br><span class="line">            <span class="keyword">while</span>  j &gt;= gap <span class="keyword">and</span> arr[j-gap] &gt;temp: </span><br><span class="line">                arr[j] = arr[j-gap] </span><br><span class="line">                j -= gap </span><br><span class="line">            arr[j] = temp </span><br><span class="line">        gap = <span class="built_in">int</span>(gap/<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><p><img src="/.io//Sorting_shellsort_anim.gif" alt="Sorting_shellsort_anim"></p><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h1 id="排序算法复杂度总结"><a href="#排序算法复杂度总结" class="headerlink" title="排序算法复杂度总结"></a>排序算法复杂度总结</h1><p><img src="/.io//%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%BB%E7%BB%93.png" alt="排序算法复杂度总结"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.runoob.com/python3/python-quicksort.html">https://www.runoob.com/python3/python-quicksort.html</a></p><p><a href="https://www.runoob.com/python3/python-bubble-sort.html">https://www.runoob.com/python3/python-bubble-sort.html</a></p><p><a href="https://www.runoob.com/python3/python-heap-sort.html">https://www.runoob.com/python3/python-heap-sort.html</a></p><p><a href="https://www.runoob.com/python3/python-merge-sort.html">https://www.runoob.com/python3/python-merge-sort.html</a></p><p><a href="https://www.runoob.com/python3/python-shellsort.html">https://www.runoob.com/python3/python-shellsort.html</a></p><p><a href="https://blog.csdn.net/z_feng12489/article/details/94634897">https://blog.csdn.net/z_feng12489/article/details/94634897</a>    shellsort</p><p><a href="https://blog.csdn.net/str_lyc/article/details/109273738">https://blog.csdn.net/str_lyc/article/details/109273738</a>    总结</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    <category term="python" scheme="https://zhugemingyi.github.io/categories/python/"/>
    
    <category term="数据结构" scheme="https://zhugemingyi.github.io/categories/python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="排序算法" scheme="https://zhugemingyi.github.io/categories/python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
